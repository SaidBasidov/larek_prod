# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Vite

Структура проекта:

- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:

- index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/main.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск

Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run dev
```

или

```
yarn
yarn dev
```

## Сборка

```
npm run build
```

или

```
yarn build
```

# Интернет-магазин «Web-Larёk»

«Web-Larёk» — это интернет-магазин с товарами для веб-разработчиков, где пользователи могут просматривать товары, добавлять их в корзину и оформлять заказы. Сайт предоставляет удобный интерфейс с модальными окнами для просмотра деталей товаров, управления корзиной и выбора способа оплаты, обеспечивая полный цикл покупки с отправкой заказов на сервер.

## Архитектура приложения

Код приложения разделен на слои согласно парадигме MVP (Model-View-Presenter), которая обеспечивает четкое разделение ответственности между классами слоев Model и View. Каждый слой несет свой смысл и ответственность:

Model - слой данных, отвечает за хранение и изменение данных.  
View - слой представления, отвечает за отображение данных на странице.  
Presenter - презентер содержит основную логику приложения и отвечает за связь представления и данных.

Взаимодействие между классами обеспечивается использованием событийно-ориентированного подхода. Модели и Представления генерируют события при изменении данных или взаимодействии пользователя с приложением, а Презентер обрабатывает эти события используя методы как Моделей, так и Представлений.

### Базовый код

#### Класс Component

Является базовым классом для всех компонентов интерфейса.
Класс является дженериком и принимает в переменной `T` тип данных, которые могут быть переданы в метод `render` для отображения.

Конструктор:  
`constructor(container: HTMLElement)` - принимает ссылку на DOM элемент за отображение, которого он отвечает.

Поля класса:  
`container: HTMLElement` - поле для хранения корневого DOM элемента компонента.

Методы класса:  
`render(data?: Partial<T>): HTMLElement` - Главный метод класса. Он принимает данные, которые необходимо отобразить в интерфейсе, записывает эти данные в поля класса и возвращает ссылку на DOM-элемент. Предполагается, что в классах, которые будут наследоваться от `Component` будут реализованы сеттеры для полей с данными, которые будут вызываться в момент вызова `render` и записывать данные в необходимые DOM элементы.  
`setImage(element: HTMLImageElement, src: string, alt?: string): void` - утилитарный метод для модификации DOM-элементов `<img>`

#### Класс Api

Содержит в себе базовую логику отправки запросов.

Конструктор:  
`constructor(baseUrl: string, options: RequestInit = {})` - В конструктор передается базовый адрес сервера и опциональный объект с заголовками запросов.

Поля класса:  
`baseUrl: string` - базовый адрес сервера  
`options: RequestInit` - объект с заголовками, которые будут использованы для запросов.

Методы:  
`get(uri: string): Promise<object>` - выполняет GET запрос на переданный в параметрах ендпоинт и возвращает промис с объектом, которым ответил сервер  
`post(uri: string, data: object, method: ApiPostMethods = 'POST'): Promise<object>` - принимает объект с данными, которые будут переданы в JSON в теле запроса, и отправляет эти данные на ендпоинт переданный как параметр при вызове метода. По умолчанию выполняется `POST` запрос, но метод запроса может быть переопределен заданием третьего параметра при вызове.  
`handleResponse(response: Response): Promise<object>` - защищенный метод проверяющий ответ сервера на корректность и возвращающий объект с данными полученный от сервера или отклоненный промис, в случае некорректных данных.

#### Класс EventEmitter

Брокер событий реализует паттерн "Наблюдатель", позволяющий отправлять события и подписываться на события, происходящие в системе. Класс используется для связи слоя данных и представления.

Конструктор класса не принимает параметров.

Поля класса:  
`_events: Map<string | RegExp, Set<Function>>)` - хранит коллекцию подписок на события. Ключи коллекции - названия событий или регулярное выражение, значения - коллекция функций обработчиков, которые будут вызваны при срабатывании события.

Методы класса:  
`on<T extends object>(event: EventName, callback: (data: T) => void): void` - подписка на событие, принимает название события и функцию обработчик.  
`emit<T extends object>(event: string, data?: T): void` - инициализация события. При вызове события в метод передается название события и объект с данными, который будет использован как аргумент для вызова обработчика.  
`trigger<T extends object>(event: string, context?: Partial<T>): (data: T) => void` - возвращает функцию, при вызове которой инициализируется требуемое в параметрах событие с передачей в него данных из второго параметра.

# Документация

Разработанную архитектуру проекта принято документировать. Во-первых, это нужно, чтобы зафиксировать принятые решения. Во-вторых — чтобы можно было ознакомить с ними других членов команды.

Для документации используйте файл `readme.md` вашего стартера. В документации уже присутствует часть, описывающая выбранный паттерн проектирования и базовый код. Подробнее про паттерны проектирования вы узнаете в следующем спринте, а сейчас нужно заняться работой с данными.

Ваша задача — дополнить документацию. Продолжайте писать текст документации ниже той части, которая дана вам в стартере. В добавленном блоке должна появиться информация о данных, которые будут использоваться в приложении и классах. Классы будут называться «Моделями данных» — они будут отвечать за хранение и работу с данными.

---

## Раздел «Данные»

В документацию нужно добавить раздел «Данные». В нём необходимо описать интерфейсы данных, которые были разработаны при разборе проекта (см. видео, которое лежит в описании первого шага).

Требуется:

- написать сами интерфейсы;
- описать их назначение.

В ходе анализа проекта было установлено, что в приложении используются две сущности, которые описывают данные: **товар** и **покупатель**.

### Интерфейс товара

Товар описывается интерфейсом `IProduct`:

```
interface IProduct {
  id: string;
  description: string;
  image: string;
  title: string;
  category: string;
  price: number | null;
}
```

Интерфейс `IProduct` содержит следующие поля:

- `id: string` — идентификатор товара;
- `description: string` — описание товара;
- `image: string` — ссылка на изображение товара;
- `title: string` — название товара;
- `category: string` — категория товара;
- `price: number | null` — цена товара; может принимать значение `null`, если у товара нет фиксированной стоимости.

### Интерфейс покупателя

Покупатель описывается интерфейсом `IBuyer`:

```
interface IBuyer {
  payment: TPayment;
  email: string;
  phone: string;
  address: string;
}
```

Интерфейс `IBuyer` содержит следующие поля:

- `payment: TPayment` — вид оплаты;
- `email: string` — электронная почта покупателя;
- `phone: string` — телефон покупателя;
- `address: string` — адрес покупателя.

---

## Раздел «Модели данных»

### Каталог товаров

Класс `Catalog` отвечает за:

- хранение массива всех товаров;
- хранение товара, выбранного для подробного отображения.

#### Конструктор

`constructor()`  
Не принимает параметров. Инициализирует каталог пустыми значениями.

#### Поля класса

`private productList: IProduct[]`  
Хранит массив всех доступных товаров.

`private selectedProduct: IProduct | null`  
Хранит товар, выбранный пользователем для подробного отображения.

#### Методы класса `Catalog`

`getSelectedProduct(): IProduct | null`  
Возвращает текущий выбранный товар или `null`, если товар не выбран.

`setSelectedProduct(product: IProduct): void`  
Сохраняет товар, выбранный для детального отображения.  
Принимает:

- `product: IProduct` — товар, который необходимо сохранить.

`getProductList(): IProduct[]`  
Возвращает массив всех товаров.

`setProductList(list: IProduct[]): void`  
Сохраняет массив товаров.  
Принимает:

- `list: IProduct[]` — массив товаров, загруженных из API или другого источника.

`getProductByID(id: number | string): IProduct`  
Возвращает товар по его идентификатору.

Принимает:

- `id: number | string` — идентификатор товара; перед поиском приводится к строке.

Особенности:

- ищет товар в `productList` по полю `id`;
- при отсутствии товара выбрасывает ошибку.

Возвращает:

- `IProduct` — найденный товар.

---

### Корзина

Класс `Cart` отвечает за хранение и управление списком товаров, выбранных пользователем для покупки.

#### Конструктор

`constructor()`  
Создаёт корзину с пустым массивом товаров.

#### Поля класса

`private CartProductList: IProduct[]`  
Хранит массив товаров, добавленных в корзину.

#### Методы класса `Cart`

`getCartProductList(): IProduct[]`  
Возвращает массив товаров, которые находятся в корзине.

`addProduct(product: IProduct): void`  
Добавляет товар в корзину.  
Принимает:

- `product: IProduct` — товар, который нужно добавить.

`deleteProduct(product: IProduct): void`  
Удаляет указанный товар из корзины.  
Принимает:

- `product: IProduct` — товар, который требуется удалить.  
  Логика:
- ищет товар в массиве по `id`,
- удаляет найденный элемент через `splice`.

`getProductListLength(): number`  
Возвращает количество товаров в корзине.

`getPriceSum(list: IProduct[]): number`  
Возвращает суммарную стоимость товаров.  
Принимает:

- `list: IProduct[]` — массив товаров, по которому выполняется расчёт.  
  Особенность:
- пропускает товары, у которых `price === null`.

`isProductInList(product: IProduct): boolean`  
Проверяет наличие товара в корзине по его `id`.  
Принимает:

- `product: IProduct`.  
  Возвращает `true`, если товар уже есть в корзине.

---

### Покупатель

Класс `Buyer` отвечает за хранение данных, которые пользователь указывает при оформлении заказа.

#### Конструктор

`constructor()`  
Создаёт модель покупателя с пустыми строковыми значениями всех полей.

#### Поля класса

`private payment: TPayment`  
Хранит выбранный вид оплаты.

`private email: string`  
Хранит электронную почту покупателя.

`private phone: string`  
Хранит телефон покупателя.

`private address: string`  
Хранит адрес покупателя.

#### Методы класса `Buyer`

`getData(): IBuyer`  
Возвращает объект данных покупателя, содержащий:  
`payment`, `email`, `phone`, `address`.

`clearData(): void`  
Полностью очищает все данные покупателя, присваивая каждому полю пустую строку.

`setData(data: Partial<IBuyer>): void`  
Частично обновляет данные покупателя.  
Позволяет изменить любое отдельное поле без удаления остальных.  
Принимает:

- `data: Partial<IBuyer>` — объект с обновляемыми значениями.  
  Логика обновления:
- если поле присутствует в переданном объекте, оно обновляется;
- остальные поля сохраняют прежние значения.

# Слой коммуникации

## Интерфейс `IOrderData`

Интерфейс `IOrderData` описывает структуру данных, отправляемых на сервер при оформлении заказа.  
Расширяет интерфейс `IBuyer`, объединяя сведения о покупателе и параметры заказа.

### Наследование

`IOrderData` наследует поля `IBuyer`, включающие контактную информацию клиента.  
Дополнительно вводит параметры, относящиеся к самому заказу.

### Поля интерфейса

`payment: TPayment`  
Способ оплаты заказа. Использует объединённый тип (`'online' | 'cash' | ''`). Наследуется от `IBuyer`.

`email: string`  
Электронная почта покупателя. Наследуется от `IBuyer`.

`phone: string`  
Контактный телефон клиента. Наследуется от `IBuyer`.

`address: string`  
Адрес доставки. Наследуется от `IBuyer`.

`total: number`  
Итоговая сумма заказа.

`products: string[]`  
Массив идентификаторов товаров, включённых в заказ.

---

## Интерфейс `IApiResponse`

Интерфейс `IApiResponse` описывает результат успешного запроса каталога с сервера.  
Используется для типизации ответа API при загрузке списка товаров.

### Поля интерфейса

`total: number`  
Количество элементов, возвращённых сервером.

`items: IProduct[]`  
Массив объектов товаров полной типизации.

---

## Класс `ApiModel`

Класс `ApiModel` представляет собой слой интеграции с серверным API.  
Использует композицию с интерфейсом `IApi`, который абстрагирует механизмы HTTP-коммуникации.  
Отвечает за загрузку каталога и отправку данных заказа.

### Конструктор

`constructor(api: IApi)`

**Параметры:**

`api: IApi` — экземпляр API-клиента, предоставляющего методы `get` и `post`.  
Сохраняется внутри класса и используется всеми методами.

### Поля класса

`private api: IApi`  
Внутренняя обёртка над функциональностью HTTP-клиента.  
Изолирует сетевую логику от бизнес-логики.

---

## Методы класса `ApiModel`

### `getProducts(): Promise<IProduct[] | void>`

Выполняет GET-запрос к эндпоинту `/product/`.  
Получает типизированный JSON-ответ `IApiResponse` и возвращает массив товаров.

**Поведение метода:**

- вызывает `this.api.get<IApiResponse>('/product/')`
- получает объект `{ total, items }`
- возвращает `items`
- в случае ошибки выводит сообщение в консоль

**Возвращаемое значение:**

- `Promise<IProduct[]>` — при успешном выполнении
- `void` — при ошибке

**Пример использования:**

`const products = await apiModel.getProducts();`

---

### `postOrder(order: IOrderData): Promise<void>`

Выполняет POST-запрос с данными заказа к эндпоинту `/order/`.

**Поведение метода:**

- отправляет запрос `POST /order/` с телом `order`
- использует `await this.api.post(...)`, чтобы корректно обрабатывать ошибки
- при ошибке выводит сообщение в консоль
- повторно выбрасывает исключение для обработки на уровне вызывающего кода

**Возвращаемое значение:**  
`Promise<void>`

**Пример использования:**  
`await apiModel.postOrder(orderData);`


# Раздел «Представление (View)»

Слой представления отвечает за отображение пользовательского интерфейса и генерацию событий в ответ на действия пользователя.  
Все классы слоя `View` **не содержат бизнес-логики** и не работают напрямую с моделями данных.  
Любое пользовательское действие приводит к генерации события, которое обрабатывается презентером.

---

## Базовые компоненты представления

### Абстрактный компонент `Component<T>`

Все классы представления наследуются от базового компонента `Component`.  
Он инкапсулирует работу с `DOM`-элементом и обновление данных.

Используется как базовый класс для всех `View`-компонентов.

---

## Карточки товаров

Для работы с карточками товаров используется иерархия классов с общим родителем.

### Абстрактный класс `Card`

`Card` — базовый класс для всех карточек товара.  
Отвечает за отображение общих данных товара.

#### Конструктор

`constructor(container: HTMLElement)`  
Принимает `DOM`-элемент карточки.

#### Поля класса

`protected titleElement: HTMLElement`  
`DOM`-элемент заголовка карточки.

`protected priceElement: HTMLElement`  
`DOM`-элемент цены товара.

#### Сеттеры

`set title(title: string)`  
Устанавливает название товара.

`set price(price: number)`  
Устанавливает цену товара.

`set priceElementText(text: string)`  
Позволяет установить произвольный текст вместо цены  
(например, «Бесценно» или «Нет в продаже»).

---

### Карточка каталога `CardCatalogView`

Отвечает за отображение карточки товара в общем каталоге.

Особенности:

- отображает краткую информацию о товаре;
- генерирует событие при клике по карточке.

Наследуется от `Card`.

---

### Карточка подробного просмотра `CardInfoView`

Отвечает за отображение карточки товара в модальном окне.

Особенности:

- отображает расширенную информацию;
- содержит кнопку добавления товара в корзину;
- генерирует события добавления товара.

Наследуется от `Card`.

---

### Карточка товара в форме `CardFormView`

Используется при отображении товара внутри форм заказа.

Особенности:

- адаптирована под контекст оформления заказа;
- не содержит лишних элементов интерфейса.

Наследуется от `Card`.

---

## Каталог товаров

### Класс `CatalogView`

`CatalogView` отвечает за отображение списка товаров на странице.

#### Назначение

- отрисовка карточек товаров;
- обновление каталога при изменении данных;
- генерация событий при взаимодействии с карточками.

---

## Корзина

### Класс `CartView`

`CartView` отвечает за отображение содержимого корзины.

#### Назначение

- отображение списка товаров в корзине;
- обновление общей стоимости;
- генерация событий удаления товаров и оформления заказа.

---

### Класс `CartHeaderView`

Отвечает за отображение корзины в шапке сайта.

#### Назначение

- отображение количества товаров в корзине;
- генерация события открытия корзины.

---

## Формы

Для всех форм используется общий абстрактный родитель.

### Абстрактный класс `FormView`

`FormView` — базовый класс для всех форм приложения.

#### Назначение

- обработка отправки формы;
- сбор данных из полей ввода;
- генерация событий изменения и отправки формы.

---

### Форма контактов `FormContactsView`

Отвечает за ввод контактных данных пользователя.

Особенности:

- ввод `email` и телефона;
- генерация события изменения данных покупателя.

Наследуется от `FormView`.

---

### Форма заказа `FormOrderView`

Отвечает за ввод данных заказа.

Особенности:

- выбор способа оплаты;
- ввод адреса доставки;
- генерация события подтверждения заказа.

Наследуется от `FormView`.

---

### Форма успешного оформления `FormSuccessView`

Отображает сообщение об успешном оформлении заказа.

Особенности:

- не содержит логики ввода;
- используется только для отображения результата.

---

## Модальные окна

### Класс `ModalContainerView`

`ModalContainerView` отвечает за отображение и управление модальным окном.

#### Важные ограничения

- от данного класса **нельзя наследоваться**;
- все компоненты, отображаемые внутри модального окна, являются самостоятельными `View`-компонентами.

#### Назначение

- открытие и закрытие модального окна;
- вставка любого компонента внутрь модального контейнера;
- генерация событий закрытия.

---

# Раздел «Презентер»

## Презентер страницы (`main.ts`)

Презентер реализован в файле `main.ts` и отвечает за координацию работы всех слоёв приложения.

### Назначение презентера

- связывает модели данных и представление;
- подписывается на события `View`-компонентов;
- обновляет модели и инициирует перерисовку интерфейса;
- управляет сценариями пользовательского взаимодействия.

### Архитектурные особенности

- в приложении используется один презентер, так как страница одна;
- презентер не вынесен в отдельный класс, логика реализована напрямую в `main.ts`;
- всё взаимодействие между слоями происходит через события.

### Ответственность презентера

- загрузка начальных данных;
- открытие и закрытие модальных окон;
- добавление и удаление товаров из корзины;
- обработка форм заказа;
- финальное оформление заказа.
